= Connect client applications to {product-proxy}

{product-proxy} is designed to mimic communication with a typical cluster based on {cass-reg}.
This means that your client applications connect to {product-proxy} in the same way that they already connect to your existing {cass-short}-based clusters.

You can communicate with {product-proxy} using the same xref:cql:ROOT:index.adoc[CQL] statements used in your existing client applications.
It understands the same messaging protocols used by {cass-short}, {dse-short}, {hcd-short}, and {astra-db}.
As a result, most client applications cannot distinguish between connections to {product-proxy} and direct connections to a {cass-short}-based cluster.

This page explains how to connect client applications to a {cass-short}-based cluster using {cass-short} drivers, and then describes the how you need to modify your client applications to connect to {product-proxy}.
It also explains how to connect `cqlsh` to {product-proxy}, which is often used in conjunction with {cass-short} drivers and during the migration process for certain validation tasks.

== Connect applications to {cass-short} clusters

A common way to connect client applications to {cass-short} clusters is with {cass-short} drivers.
These drivers can connect to {cass-short}-based clusters, execute queries, iterate through results, access metadata about the clusters, and perform other related activities.
For available drivers and driver documentation, see xref:datastax-drivers:compatibility:driver-matrix.adoc[].

The following pseudocode provides simplified examples of the way a {cass-short} driver interacts with {cass-short} clusters.
Specifically, these examples are for {astra-db} and self-managed {dse-short}, {hcd-short}, and open-source {cass-short} clusters.

This pseudocode is for illustration purposes only; the exact syntax depends on your driver language and version.
For specific instructions and examples, see xref:datastax-drivers:connecting:connect-cloud.adoc[].

[tabs]
======
Self-managed {cass-short} clusters::
+
--
[source,pseudocode]
----
// Create an object to represent a Cassandra cluster
// This example listens for connections at 10.20.30.40 on the default port 9042
// Username and password are required only if authentication is enabled on the cluster
Cluster my_cluster = Cluster.build_new_cluster(
    contact_points = "10.20.30.40",
    username="cluster_username",
    password="cluster_password"
)

// Connect the Cluster object to the Cassandra cluster, returning a Session
Session my_session = my_cluster.connect()

// Execute a query, returning a ResultSet
ResultSet my_result_set = my_session.execute("select release_version from system.local")

// Retrieve a specific column from the first row of the result set
String release_version = my_result_set.first_row().get_column("release_version")

// Close the Session and Cluster
my_session.close()
my_cluster.close()

// Print the data retrieved from the result set
print(release_version)
----
--

{astra-db}::
+
--
[source,text]
----
// Create an object to represent a Cassandra cluster (an Astra database)
// Don't specify contact points when connecting to Astra DB
// All connection information is implicitly passed in the SCB
Cluster my_cluster = Cluster.build_new_cluster(
    username="token",
    password="AstraCS:...",
    secure_connect_bundle="/path/to/scb.zip"
)

// For legacy applications that must use client ID and secret authentication:
// Cluster my_cluster = Cluster.build_new_cluster(username="my_AstraDB_client_ID", password="my_AstraDB_client_secret", secure_connect_bundle="/path/to/scb.zip")

// Connect the Cluster object to the database, returning a Session
Session my_session = my_cluster.connect()

// Execute a query, returning a ResultSet
ResultSet my_result_set = my_session.execute("select release_version from system.local")

// Retrieve a specific column from the first row of the result set
String release_version = my_result_set.first_row().get_column("release_version")

// Close the Session and Cluster
my_session.close()
my_cluster.close()

// Print the data retrieved from the result set
print(release_version)
----
--
======

Review your client application's code to understand how it connects to your existing {cass-short}-based clusters.
Then, proceed to <<connect-applications-to-zdm-proxy>> to learn how to modify that code to connect to {product-proxy} instead.

[#connect-applications-to-zdm-proxy]
== Connect applications to {product-proxy}

By design, {product-proxy} should be transparent to your client application.
This means that connecting your client application to {product-proxy} should be seamless and nearly identical to the direct cluster connection.
However, there are some considerations and adjustments you might need to make for {product-proxy}.

=== Understand how {product-proxy} handles certain client behaviors

If you haven't done so already, thoroughly review the xref:ROOT:feasibility-checklists.adoc[compatibility requirements for {product-proxy}].
This ensures that your client application's code is compatible with {product-proxy}, and you understand how certain operations and behaviors are handled by {product-proxy}.
For example:

* xref:ROOT:feasibility-checklists.adoc#driver-retry-policy-and-query-idempotence[Driver retry policy and query idempotence]
* xref:ROOT:feasibility-checklists.adoc#client-compression[Client compression]
* xref:ROOT:feasibility-checklists.adoc#zdm-proxy-ignores-token-aware-routing[Token-aware routing]

=== Set connection points

Connect your client application to {product-proxy} instead of directly to the origin cluster by modifying the client's connection points.

Typically, this involves setting the client's connection points to the IP addresses or hostnames of the local {product-proxy} instances.
The specific connection points for your migration depend on where and how you configured your xref:ROOT:deployment-infrastructure.adoc[{product-proxy} infrastructure].

[#provide-authentication-credentials]
=== Provide authentication credentials

Make sure {product-proxy} receives the correct authentication credentials from your client application.
You might need to change the credentials set in your client application depending on your origin and target cluster configuration.

With or without {product-proxy}, client applications must provide cluster credentials to authenticate requests.
When a client connects directly to a cluster, it provides the authentication credentials for that cluster.
When a client connects to {product-proxy}, the client still provides only one set of credentials because {product-proxy} is designed to be invisible to the client application.

{product-proxy} uses the credentials provided by the client to forward requests to one of the clusters.
To forward requests to the other cluster, {product-proxy} uses the credentials defined in `xref:ROOT:deploy-proxy-monitoring.adoc#cluster-and-core-configuration[zdm_proxy_cluster_config.yml]`.

.Credential usage by {product-proxy} when authentication is required for both clusters
image::zdm-proxy-credential-usage.png[{product-proxy} credentials usage when authentication is required for both clusters, 550]

The credentials that {product-proxy} expects to receive from the client depend on the authentication requirements of the origin and target clusters.
Make sure the client passes the correct credentials for your cluster configuration:

* *Authentication required for both clusters*: Your client application must supply credentials for the target cluster.
* *Authentication required for target cluster only*: Your client application must supply credentials for the target cluster.
* *Authentication required for origin cluster only*: Your client application must supply credentials for the origin cluster.
* *No authentication required for either cluster*: Your client application doesn't need to supply any cluster credentials.

After you determine which cluster's credentials are required, set the appropriate credentials in your client application:

* **Self-managed clusters**: Provide a valid `username` and `password` to access the cluster.
+
Make sure the user has the appropriate permissions to perform the operations requested by the client application during the migration.

* **{astra-db}**: xref:astra-db-serverless:administration:manage-application-tokens.adoc[Generate an application token] with a role that has sufficient permissions to perform the operations requested by the client application during the migration.
Then, in your client application, set the `username` to the literal string `token`, and set the `password` to the actual application token value (`AstraCS:...`).
+
[IMPORTANT]
====
_Don't_ provide a xref:astra-db-serverless:databases:secure-connect-bundle.adoc[{scb}] when connecting your client application to {product-proxy}.

If you include the {scb-short}, the driver ignores the {product-proxy} connection points and connects exclusively to your {astra-db} database instead of {product-proxy}.
====
+
For connections to early {astra} databases with long-lived tokens created prior to the unified `token` approach, you can set the `username` to the token's `clientId` and the `password` to the token's `secret`.

For more information about cluster credentials for {product-proxy}, see xref:ROOT:deploy-proxy-monitoring.adoc#cluster-and-core-configuration[Cluster and core configuration].

== Sample client applications

[IMPORTANT]
====
These sample applications are for demonstration purposes only.
They are not intended for production use or for production-scale performance testing.

To test your target cluster's ability to handle production workloads, you can xref:ROOT:enable-async-dual-reads.adoc[enable asynchronous dual reads].

To assess the performance of {product-proxy}, {company} recommends http://docs.nosqlbench.io/getting-started/[NoSQLBench].
====

The following sample client applications demonstrate how to use the Java driver with {product-proxy} and the origin and target for that proxy.

See your driver's documentation for code samples that are specific to your chosen driver, including cluster connection examples and statement execution examples.

You can use the provided sample client applications, in addition to your own client applications, to validate that your {product-proxy} deployment is orchestrating read and write requests as expected between the origin cluster, target cluster, and your client applications.

{product-demo}::
https://github.com/alicel/zdm-demo-client/[{product-demo}] is a minimal Java web application which provides a simple, stripped-down example of an application built to work with {product-proxy}.
After updating connection information you can compile and run the application locally and interact with it using HTTP clients such as `curl` or `wget`.
+
You can find the details of building and running {product-demo} in the https://github.com/alicel/zdm-demo-client/blob/master/README.md[README].

[[_themis_client]]
Themis client::
https://github.com/absurdfarce/themis[Themis] is a Java command-line client application that allows you to write randomly generated data directly to the origin cluster, directly to the target cluster, or indirectly to both clusters through {product-proxy}.
Then, you can use the client application to query the data and confirm that {product-proxy} is reading and writing data from the expected sources.
+
Configuration details for the clusters and {product-proxy} are defined in a YAML file.
For more information, see the https://github.com/absurdfarce/themis/blob/main/README.md[Themis README].
+
In addition to being a validation tool, Themis also provides an example of a larger client application that uses the Java driver to connect to {product-proxy}, or directly to a {cass-short} cluster, and perform operations.
The configuration logic, as well as the cluster and session management code, are separated into distinct packages to make them easy to understand.

== Connect cqlsh to {product-proxy}

`cqlsh` is a command-line tool that you can use to send CQL statements and `cqlsh`-specific commands to your {cass-short}-based clusters, including {astra-db}, {dse-short}, {hcd-short}, and {cass} databases.

You can use your database's included version of `cqlsh`, or you can download and run a standalone `cqlsh`.

Your origin and target clusters must have a common `cql_version` between them.
If there is no CQL version that is compatible with both clusters, `cqlsh` won't be able to connect to {product-proxy}.

To connect `cqlsh` to a {product-proxy} instance, do the following:

. On a machine that can connect to your {product-proxy} instance, xref:cql:connect:start-cqlsh-linux-mac.adoc[download and install `cqlsh`].
+
Any version of `cqlsh` can connect to {product-proxy}, but some clusters require a specific `cqlsh` version.

. Start `cqlsh` with your {product-proxy} connection details:
+
[source,shell,subs="+quotes"]
----
./cqlsh **ZDM_PROXY_IP** **PORT** -u **USERNAME** -p **PASSWORD**
----
+
Replace the following:
+
* `**ZDM_PROXY_IP**`: The IP address of your {product-proxy} instance.
* `**PORT**`: The port on which the {product-proxy} instance listens for client connections.
If you are using the default port, 9042, you can omit this argument.
* `**USERNAME**` and `**PASSWORD**`: Valid cluster authentication credentials, depending on the authentication requirements for your origin and target clusters:
+
** *Authentication required for both clusters*: Provide credentials for the target cluster.
** *Authentication required for target cluster only*: Provide credentials for the target cluster.
** *Authentication required for origin cluster only*: Provide credentials for the origin cluster.
** *No authentication required for either cluster*: Omit the `-u` and `-p` arguments.

+
--
For a self-managed cluster, provide a valid `username` and `password` to access the cluster.

For {astra-db}, the username is the literal string `token`, and the password is an xref:astra-db-serverless:administration:manage-application-tokens.adoc[{astra} application token], such as `-u token -p AstraCS:...`.

[IMPORTANT]
====
For {astra-db}, _don't_ use the {scb-short} to connect `cqlsh` to {product-proxy}.
Only use an application token.

If you include the {scb-short}, `cqlsh` ignores all other connection arguments and connects exclusively to your {astra-db} database instead of {product-proxy}.
====
--

== Next steps

After you connect your client applications to {product-proxy}, you can begin xref:ROOT:migrate-and-validate-data.adoc[Phase 2] of the migration, which is the data migration phase.