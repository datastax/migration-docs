= Frequently Asked Questions
:navtitle: FAQs
:page-tag: migration,zdm,zero-downtime,zdm-proxy,faq
ifdef::env-github,env-browser,env-vscode[:imagesprefix: ../images/]
ifndef::env-github,env-browser,env-vscode[:imagesprefix: ]

If you're new to the {company} {product} features, these FAQs are for you.

== What is meant by {product}?

{product} ({product-short}) means the ability for you to reliably migrate client applications and data between CQL clusters with no interruption of service.

{product-short} lets you accomplish migrations without the need to change your client application code, and with only minimal configuration changes. While in some cases you may need to make some minor changes at the client application level, these changes will be minimal and non-invasive, especially if your client application uses an externalized property configuration for contact points.

The suite of {product-short} tools enables you to migrate the real-time activity generated by your client applications, as well as transfer your existing data, always with a simple rollback strategy that does not require any downtime.

It is important to note that the {product} process requires you to be able to perform rolling restarts of your client applications during the migration.

[TIP]
====
In the context of migrating between clusters (client applications and data), the examples in this guide sometimes refer to the migration to our cloud-native database environment, {astra-db}.

However, it is important to emphasize that the {product-proxy} can be freely used to migrate without downtime between any combination of CQL clusters of any type. In addition to {astra-db}, examples include {cass-reg} or {dse}.
====

== Can you illustrate the overall workflow and phases of a migration?

See the diagrams of the {product-short} xref:introduction.adoc#_migration_phases[migration phases].

== Do you offer an interactive self-guided lab to help me learn about {product-short} migrations at my own pace?

Yes! Here's a fun way to learn.

include::partial$interactive-lab.adoc[]

The interactive lab spans the pre-migration prerequisites and each of the five key migration phases.

== What components are provided with {product-short}?

{company} {product} includes the following:

* xref:glossary.adoc#zdm-proxy[**{product-proxy}**] is a service that operates between xref:glossary.adoc#origin[**Origin**], which is your existing cluster, and xref:glossary.adoc#target[**Target**], which is the cluster to which you are migrating.
* **{product-automation}** is an Ansible-based tool that allows you to deploy and manage the {product-proxy} instances and associated monitoring stack.
To simplify its setup, the suite includes the {product-utility}.
This interactive utility creates a Docker container acting as the Ansible Control Host.
The Ansible playbooks constitute the {product-automation}.
* **{cass-migrator}** is designed to:
** Connect to your clusters and compare the data between Origin and Target.
** Report differences in a detailed log file.
** Reconcile any missing records and fix any data inconsistencies between Origin and Target by enabling `autocorrect` in a configuration file.
* **{dsbulk-migrator}** is provided to migrate smaller amounts of data from Origin to Target.
* Well-defined steps in this migration documentation, organized as a sequence of phases.

== What exactly is {product-proxy}?

{product-proxy} is a component designed to seamlessly handle the real-time client application activity while a migration is in progress. See xref:introduction.adoc#_role_of_zdm_proxy[here] for an overview.

== What are the benefits of {product} and its use cases?

Migrating client applications between clusters is a need that arises in many scenarios. For example, you may want to:

* Move to a cloud-native, managed service such as {astra-db}.
* Migrate your client application to a brand new cluster, on a more recent version and perhaps on new infrastructure, or even a different CQL database entirely, without intermediate upgrade steps and ensuring that you always have an easy way to rollback in case of issues.
* Separate out a client application from a shared cluster to a dedicated one.
* Consolidate client applications, currently running on separate clusters, into fewer clusters or even a single one.

Bottom line: You want to migrate your critical database infrastructure without risk or concern that your users' experiences will be affected.

== Which releases of {cass-short} or {dse-short} are supported for migrations?

include::partial$supported-releases.adoc[]

include::partial$migration-scenarios.adoc[]

== Does {product-short} migrate clusters?

{product-short} does not migrate clusters.
With {product-short}, we are migrating data and applications *between clusters*.
At the end of the migration, your application will be running on your new cluster, which will have been populated with all the relevant data.

== What challenges does {product-short} solve?

Before {company} {product} was available, migrating client applications between clusters involved granular and intrusive client application code changes, extensive migration preparation, and a window of downtime to the client application's end users.

{product-short} allows you to leverage mature migration tools that have been used with large scale enterprises and applications to make migrations easy and transparent to end users.

== What is the pricing model?

The suite of {product} tools from {company} is free and open-sourced.

== Is there support available if I have questions or issues during our migration?

{product-proxy} and related software tools in the migration suite include technical assistance by https://support.datastax.com/s/[{company} Support] for {dse-short} and Luna subscribers, and {astra-db} users who are on an Enterprise plan.
Free and Pay As You Go plan users do not have support access and must raise questions in the {astra_ui} chat.
https://www.datastax.com/products/luna[Luna] is a subscription to the {cass} support and expertise at {company}.

For any observed problems with the {product-proxy}, submit a https://github.com/datastax/zdm-proxy/issues[GitHub Issue] in the {product-proxy} GitHub repo.

Additional examples serve as templates, from which you can learn about migrations.
{company} does not assume responsibility for making the templates work for specific use cases.

== Where are the public GitHub repos?

All the {company} {product} GitHub repos are public and open source.
You are welcome to read the code and submit feedback via GitHub Issues per repo.
In addition to sending feedback, you may submit Pull Requests (PRs) for potential inclusion.

To submit PRs, you must for first agree to the https://cla.datastax.com/[{company} Contribution License Agreement (CLA)].

* https://github.com/datastax/zdm-proxy[{product-proxy}] repo.

* https://github.com/datastax/zdm-proxy-automation[{product-automation}] repo for the Ansible-based {product-automation}, which includes the {product-utility}.

* https://github.com/datastax/cassandra-data-migrator[cassandra-data-migrator] repo for the tool that supports migrating larger data quantities as well as detailed verifications and reconciliation options.

* https://github.com/datastax/dsbulk-migrator[dsbulk-migrator] repo for the tool that allows simple data migrations without validation and reconciliation capabilities.

// * https://github.com/datastax/migration-docs[Migration documentation]


== Does {product-proxy} support Transport Layer Security (TLS)?

Yes, and here's a summary:

* For application-to-proxy TLS, the application is the TLS client and the {product-proxy} is the TLS server.
One-way TLS and Mutual TLS are both supported.
* For proxy-to-cluster TLS, the {product-proxy} acts as the TLS client and the cluster as the TLS server.
One-way TLS and Mutual TLS are both supported.
* When the {product-proxy} connects to {astra-db} clusters, it always implicitly uses Mutual TLS.
This is done through the Secure Connect Bundle (SCB) and does not require any extra configuration.

For TLS details, see xref:tls.adoc[].

== How does {product-proxy} handle Lightweight Transactions (LWTs)?

{product-proxy} handles LWTs as write operations.
The proxy sends the LWT to Origin and Target clusters concurrently, and waits for a response from both.
{product-proxy} will return a `success` status to the client if both Origin and Target send successful acknowledgements, or otherwise will return a `failure` status if one or both do not return an acknowledgement.

What sets LWTs apart from regular writes is that they are conditional. For important details, including the client context for a returned `applied` flag, see xref:feasibility-checklists.adoc#_lightweight_transactions_and_the_applied_flag[Lightweight Transactions and the `applied` flag].

== Can {product-proxy} be deployed as a sidecar?

{product-proxy} should not be deployed as a sidecar.

{product-proxy} was designed to mimic a {cass-short} cluster.
For this reason, we recommend deploying multiple {product-proxy} instances, each running on a dedicated machine, instance, or VM.

For best performance, this deployment should be close to the client applications (ideally on the same local network) but not co-deployed on the same machines as the client applications.

This way, each client application instance can connect to all {product-proxy} instances, just as it would connect to all nodes in a {cass-short} cluster (or datacenter).

This deployment model gives maximum resilience and failure tolerance guarantees and allows the client application driver to continue using the same load balancing and retry mechanisms that it would normally use.

Conversely, deploying a single {product-proxy} instance would undermine this resilience mechanism and create a single point of failure, which could affect the client applications if one or more nodes of the underlying clusters (Origin or Target) go offline.
In a sidecar deployment, each client application instance would be connecting to a single {product-proxy} instance, and would therefore be exposed to this risk.

For more information, see xref:deployment-infrastructure.adoc#_choosing_where_to_deploy_the_proxy[Choosing where to deploy the proxy].

== What are the benefits of using a cloud-native database?

When moving your client applications and data from on-premise {cass-short} Query Language (CQL) based data stores ({cass-short} or {dse-short}) to a cloud-native database (CNDB) like {astra-db}, it's important to acknowledge the fundamental differences ahead.

With on-premise infrastructure, you have total control of the datacenter's physical infrastructure, software configurations, and your custom procedures.
At the same time, with on-premise clusters you take on the cost of infrastructure resources, maintenance, operations, and personnel.

Ranging from large enterprises to small teams, IT managers, operators, and developers are realizing that the Total Cost of Ownership (TCO) with cloud solutions is much lower than continuing to run on-prem physical data centers.

A CNDB like {astra-db} is a different environment.
Running on proven cloud providers like AWS, Google Cloud, and Azure, {astra-db} greatly reduces complexity and increases convenience by surfacing a subset of configurable settings, providing a well-designed UI known as {astra_ui}, plus a set of APIs and commands to interact with your {astra-db} organizations and databases.
