= Set up {product-automation} with {product-utility}

{product-automation} uses Ansible to deploy and configure the {product-proxy} instances and the associated monitoring stack.
Specifically, these configuration processes are defined in Ansible playbooks that you execute from the Ansible Control Host container.

First, you must use {product-utility} to set up the Ansible Control Host container, and then you can xref:deploy-proxy-monitoring.adoc[use {product-automation} to deploy your {product-proxy} instances] and the xref:ROOT:metrics.adoc[monitoring stack].
After you complete both of these procedures, you will have an active and fully monitored {product-proxy} deployment.

{product-utility} is a Golang (Go) executable program that runs anywhere.
This utility prompts you for a few configuration values, with helpful embedded explanations and error handling, and then it creates and prepares the Ansible Control Host container automatically.
From this container, you will configure and run the {product-automation} Ansible playbooks.

image::ROOT:docker-container-and-zdm-utility.png[{product-proxy} connections from Docker container created by {product-utility}]

For more information about {product-utility} and {product-automation}, see xref:ROOT:components.adoc[].

== Prerequisites

Before running {product-utility} to create the Ansible Control Host container, you must complete the following prerequisites:

* xref:ROOT:deployment-infrastructure.adoc[Provision all {product-proxy} infrastructure]: This means your server machines are ready, and you know their IP addresses.
+
This infrastructure can be on-premise or in any cloud provider of your choice.
+
If your {product-proxy} machines use private IPs, which are recommended for production deployments, configure these before running {product-utility}.
If you enable private IPs later, you must reconfigure and redeploy your {product-proxy} instances.
This is a disruptive operation that requires a small amount of downtime because the deployment playbook decommissions and recreates all {product-proxy} containers simultaneously.

* https://docs.docker.com/engine/install/#server[Install Docker] on the machine that will run the Ansible Control Host container, and ensure that the `docker` command https://docs.docker.com/engine/install/linux-postinstall/#manage-docker-as-a-non-root-user[doesn't require superuser privileges].
+
[TIP]
====
You don't need to install Docker on any other machines.
{product-automation} will install Docker on the other {product-proxy} machines as part of the deployment process.
====

== Alternative Docker configurations

If you don't want to pull images from a specific registry, or your servers don't connect to the public internet, there are two alternative Docker configurations you can use.

[tabs]
======
Pull from local cache::
+
--
If your servers can connect directly to a local Docker registry, the servers can pull containers from the public internet by way of the local Docker registry.
With this option, only the local Docker registry is connected to the public internet.
For instructions, see the Docker documentation on https://docs.docker.com/docker-hub/mirror/[configuring a pull-through cache].
--

Airgapped local registry::
+
--
Local registries that aren't connected to the internet require administrators to manually add containers to their registry.
For {product-utility}, you need the following five containers to install and configure the jumphost, {product-proxy}, and monitoring:

[source,plaintext]
----
grafana/grafana:7.5.17
prom/prometheus:latest
datastax/zdm-ansible:2.x
prom/node-exporter:latest
datastax/zdm-proxy:2.x
----
--
======

== Use a jumphost to deploy the Ansible Control Host container

This guide uses a jumphost to run the Ansible Control Host container.

A jumphost is a server on a network that is used to access and manage devices in a separate security zone, providing a controlled means of access between them.
The jumphost can be, for example, a Linux server machine that is able to access the server machines that you wish to use for your {product-proxy} deployment.

The jumphost is used to access the {product-proxy} machines, and run the Ansible Control Host container, from which you run {product-automation}.
In this example, the jumphost also runs the {product-proxy} monitoring stack, which uses Prometheus and Grafana to expose the metrics of all the {product-proxy} instances to preconfigured dashboards.
However, you can run the monitoring stack on a different machine.

. Add SSH keys to the jumphost.
+
To run {product-automation}, the Ansible Control Host must be able to connect to all other instances of the {product-proxy} deployment.
For this reason, it needs to have the SSH key required by those instances.
+
[TIP]
====
To simplify accessing the jumphost and {product-proxy} instances from your machine, you can create a xref:ROOT:deployment-infrastructure.adoc#connect-to-zdm-proxy-infrastructure-from-an-external-machine[custom SSH configuration file].
These steps assume that this file exists.
====
+
From your local machine, transfer (`scp`) the SSH private key for the {product-proxy} deployment to the jumphost.
For example:
+
[source,bash]
----
scp -F path/to/zdm_ssh_config zdm_key_name jumphost:
----

. Connect to the jumphost.
+
[source,bash]
----
ssh -F path/to/zdm_ssh_config jumphost
----

. From the jumphost, download the latest {product-utility} executable from the {product-automation-repo}/releases[{product-automation} GitHub repository] {product-automation-shield}.
+
The package filename format is `zdm-util-**PLATFORM**-**VERSION**.tgz`.
The following example downloads {product-utility} version 2.3.1 for Linux amd64.
To download a different package, change the version and package filename accordingly.
+
[source,bash,subs="+attributes"]
----
wget {product-automation-repo}/releases/download/v2.3.1/zdm-util-linux-amd64-v2.3.1.tgz
----

. Extract the archive:
+
[source,bash]
----
tar -xvf zdm-util-linux-amd64-v2.3.1.tgz
----

. Run {product-utility}:
+
[source,bash]
----
./zdm-util-v2.3.1
----

. Enter configuration values as you are prompted for them.
{product-utility} creates and initializes the Ansible Control Host container after it has all required configuration values.
+
{product-utility} validates each value that you enter.
In case of invalid values, it prompts you for the variable again and prints a message to help you fix potential problems.
You have five attempts to enter valid values.
If all five attempts are invalid, you must rerun {product-utility}.
+
[TIP]
====
{product-utility} stores your provided configuration values in a file named `ansible_container_init_config` in the current directory.
If you run the utility again, it detects this file, and then asks you if you want to use the existing configuration or discard it.
If the file contains any invalid values, you are prompted for the missing or invalid parameters only.

You can also pass a custom configuration file to {product-utility} with the optional command-line parameter `-utilConfigFile`.
For example:

[source,bash]
----
./zdm-util-v2.3.1 -utilConfigFile your_config_file
----
====

. Enter the path and name of the SSH private key required to access the proxy hosts:
+
[source,bash]
----
~/my-zdm-key
----

. Enter the common prefix of the private IP addresses of the proxy hosts:
+
[source,bash]
----
172.18.*
----

. When prompted, provide or create an Ansible inventory file:
+
* If you have an existing Ansible inventory file that is present on the jumphost, specify that file.
* If you don't have an Ansible inventory file, type kbd:[N].
{product-utility} prompts you for the required values, and then creates a `zdm_ansible_inventory` file in the working directory.

. Indicate whether this deployment is for local testing and evaluation (such as when you're creating a demo or experimenting with {product-proxy}) or not.
For production deployments, type kbd:[N].
+
[TIP]
====
Depending on your environment and {product-utility} configuration choices, your prompts might differ from the examples shown here.
You might receive additional prompts that aren't given here, or you might bypass some prompts.
In any case, the utility guides you through the process with helpful hints and troubleshooting guidance.
Regardless of the individual prompts, a successful outcome always results in a configured Ansible Control Host container that is ready to run {product-automation}.
====

. For production deployments, enter at least three proxy private IP addresses for the machines that will run the {product-proxy} instances.
For local testing and evaluation, only one proxy private IP address is required.
+
Enter each IP address on a separate line, for example:
+
[source,bash]
----
172.18.10.137
172.18.11.88
172.18.12.191
----
+
When you are done entering IP addresses, press kbd:[Return] at the blank prompt.

. Optional: When prompted, enter the private IP address of the machine where you want to deploy the {product-proxy} monitoring stack.
+
You can use the jumphost or a different machine, as long as it can connect to the {product-proxy} instances over TCP on ports 9100 (to collect host-level metrics) and the port on which {product-proxy} exposes its own metrics, typically 14001.
+
You can skip this step if you haven't decided which machine to use for monitoring, or you want to use your own monitoring stack.
+
[IMPORTANT]
====
{company} strongly recommends that you configure a monitoring instance to expose xref:ROOT:metrics.adoc[{product-proxy} metrics and preconfigured dashboards] with {product-automation}.
This is the most simplified approach to {product-proxy} montioring, and it is preferred unless you intend (or are required) to use a monitoring stack that you already have.

Metrics are essential for understanding the performance and health of your {product-proxy} instances, especially for migrations that run over multiple days or weeks.
You cannot rely solely on information in the logs.
Logs report connection or protocol errors, but they don't provide enough information about how {product-proxy} is functioning and how each cluster is responding.
In contrast, metrics provide insightful data and graphs illustrating key values and changes over time.
====
+
The following example uses the same IP address as the Ansible Control Host machine, which is the jumphost machine where {product-utility} is running:
+
[source,bash]
----
172.18.100.128
----

. Review the configuration summary printed to the terminal by {product-utility}.
At this point, {product-utility} has created the Ansible inventory file name `zdm_ansible_inventory` (unless you provided your own custom file), and it has written the {product-utility} configuration to `ansible_container_init_config`.
+
image::ROOT:zdm-go-utility-results3.png[A summary of the configuration provided is displayed in the terminal]

. Type kbd:[Y] to continue and trigger the following processes:
+
.. {product-utility} creates and downloads the image of the Ansible Docker container.
.. {product-utility} creates, configures, and starts the Ansible Control Host container.
.. {product-utility} prints a message when the Ansible container is fully initialized and ready to use.

+
image::ROOT:zdm-go-utility-success3.png[Ansible Docker container success messages]

== Next steps

After you use {product-utility} to set up the Ansible Control Host container, xref:deploy-proxy-monitoring.adoc[use {product-automation} to deploy your {product-proxy} instances].