= Compare {company} migration tools
:navtitle: Compare migration tools
:description: Learn about {company} migration tools.
:page-tag: migration,zdm,zero-downtime,zdm-proxy,components

The {company} {product} ({product-short}) toolkit includes {product-proxy}, {product-utility}, and {product-automation}, and several data migration tools.

For live migrations, {product-proxy} orchestrates activity-in-transition on your clusters.
{product-utility} and {product-automation} facilitate the deployment and management of {product-proxy}.

To move and validate data, you use data migration tools.
You can use these tools alone or with {product-proxy}.

== {product-proxy}

The main component of the {company} {product} toolkit is {product-proxy-repo}[{product-proxy}], which is designed to be a lightweight proxy that handles all real-time requests generated by your client applications during the migration process.
This tool is open-source software that is open for xref:ROOT:contributions.adoc[public contributions].

{product-proxy} is an orchestrator for monitoring application activity and keeping multiple clusters (databases) in sync through dual writes.
{product-proxy} isn't linked to the actual migration process.
It doesn't perform data migrations and it doesn't have awareness of ongoing migrations.
Instead, you use a <<data-migration-tools,data migration tool>> to perform the data migration and validate migrated data.

{product-proxy} reduces risks to upgrades and migrations by decoupling the origin cluster from the target cluster and maintaining consistency between both clusters.
You decide when you want to switch permanently to the target cluster.

After migrating your data, changes to your application code are usually minimal, depending on your client's compatibility with the origin and target clusters.
Typically, you only need to update the connection string.

[#how-zdm-proxy-handles-reads-and-writes]
=== How {product-proxy} handles reads and writes

{company} created {product-proxy} to orchestrate requests between a client application and both the origin and target clusters.
These clusters can be any CQL-compatible data store, such as {cass-reg}, {dse}, and {astra-db}.

During the migration process, you designate one cluster as the _primary cluster_, which serves as the source of truth for reads.
For the majority of the migration process, this is typically the origin cluster.
Towards the end of the migration process, when you are ready to read from your target cluster, you set the target cluster as the primary cluster.

==== Writes

{product-proxy} sends every write operation (`INSERT`, `UPDATE`, `DELETE`) synchronously to both clusters at the requested consistency level:

* If the write is acknowledged in both clusters at the requested consistency level, then the operation returns a successful write acknowledgement to the client that issued the request.
* If the write fails in either cluster, then {product-proxy} passes a write failure, originating from the primary cluster, back to the client.
The client can then retry the request, if appropriate, based on the client's retry policy.

This design ensures that new data is always written to both clusters, and that any failure on either cluster is always made visible to the client application.

For information about how {product-proxy} handles lightweight transactions (LWTs), see xref:feasibility-checklists.adoc#_lightweight_transactions_and_the_applied_flag[Lightweight Transactions and the applied flag].

==== Reads

By default, {product-proxy} sends all reads to the primary cluster, and then returns the result to the client application.

If you enable _asynchronous dual reads_, {product-proxy} sends asynchronous read requests to the secondary cluster (typically the target cluster) in addition to the synchronous read requests that are sent to the primary cluster.

This feature is designed to test the target cluster's ability to handle a production workload before you permanently switch to the target cluster at the end of the migration process.

With or without asynchronous dual reads, the client application only receives results from synchronous reads on the primary cluster.
The results of asynchronous reads aren't returned to the client because asynchronous reads are for testing purposes only.

For more information, see xref:ROOT:enable-async-dual-reads.adoc[].

=== High availability and multiple {product-proxy} instances

{product-proxy} is designed to be highly available and run a clustered fashion to avoid a single point of failure.

With the exception of local test environments, {company} recommends that all {product-proxy} deployments have multiple {product-proxy} instances.
Deployments typically consist of three or more instances.

[TIP]
====
Throughout the {product-short} documentation, the term _{product-proxy} deployment_ refers to the entire deployment, and _{product-proxy} instance_ refers to an individual proxy process in the deployment.
====

You can scale {product-proxy} instances horizontally and vertically.
To avoid downtime when applying configuration changes, you can perform rolling restarts on your {product-proxy} instances.

For simplicity, you can use the {product-utility} and {product-automation} to set up and run Ansible playbooks that deploy and manage {product-proxy} and its monitoring stack.

== {product-utility} and {product-automation}

You can use {product-automation-repo}[{product-utility} and {product-automation}] to set up and run Ansible playbooks that deploy and manage {product-proxy} and the associated monitoring stack.

https://www.ansible.com/[Ansible] is a suite of software tools that enables infrastructure as code.
It is open source and its capabilities include software provisioning, configuration management, and application deployment functionality.
The Ansible automation for {product-short} is organized into playbooks, each implementing a specific operation.
The machine from which the playbooks are run is known as the Ansible Control Host.
In {product-short}, the Ansible Control Host runs as a Docker container.

You use the {product-utility} to set up Ansible in a Docker container, and then you use {product-automation} to run the Ansible playbooks from the Docker container created by {product-utility}.

The {product-utility} creates the Docker container acting as the Ansible Control Host, from which {product-automation} allows you to deploy and manage the {product-proxy} instances and the associated monitoring stack, which includes Prometheus metrics and Grafana visualizations of the metrics data.

To use {product-utility} and {product-automation}, you must prepare the recommended infrastructure, as explained in xref:deployment-infrastructure.adoc[].

For more information, see xref:setup-ansible-playbooks.adoc[] and xref:deploy-proxy-monitoring.adoc[].

== Data migration tools

You use data migration tools to move data between clusters and validate the migrated data.

You can use these tools alone or with {product-proxy}.

=== {sstable-sideloader}

{sstable-sideloader} is a service running in {astra-db} that imports data from snapshots of your existing {cass-short}-based cluster.
This tool is exclusively for migrations that move data to {astra-db}.

For more information, see xref:sideloader:sideloader-zdm.adoc[].

=== {cass-migrator}

You can use {cass-migrator} ({cass-migrator-short}) to migrate and validate tables between {cass-short}-based clusters.
It is best for large migrations and for migrations that need advanced features, such as for detailed logging, data verification, table column renaming, and reconciliation.

{cass-migrator-short} offers extensive functionality and configuration options to support large and complex migrations as well as post-migration data validation.

You can use {cass-migrator-short} by itself, with {product-proxy}, or for data validation after using another data migration tool, such as {sstable-sideloader}.

For more information, see xref:ROOT:cassandra-data-migrator.adoc[].

=== {dsbulk-migrator}

{dsbulk-migrator} is an extension of {dsbulk-loader}.
It is best for smaller migrations or migrations that don't require data validation during the migration process.

In addition to loading and unloading CSV and JSON data, you can use {dsbulk-migrator} to transfer data between databases.
It can read data from a table in your origin database, and then write that data to a table in your target database.

You can use {dsbulk-migrator} alone or with {product-proxy}.

For more information, see xref:ROOT:dsbulk-migrator.adoc[].

=== Custom data migration processes

If you want to write your own custom data migration processes, you can use a tool like Apache Spark(TM).