= Compare {company} migration tools
:navtitle: Compare migration tools
:description: Learn about {company} migration tools.

The {company} {product} ({product-short}) toolkit includes {product-proxy}, {product-utility}, {product-automation}, and several data migration tools.

For live migrations, {product-proxy} orchestrates activity-in-transition on your clusters.
{product-utility} and {product-automation} facilitate the deployment and management of {product-proxy}.

To move and validate data, you use data migration tools.
You can use these tools alone or with {product-proxy}.

== {product-proxy}

The main component of the {company} {product} toolkit is {product-proxy-repo}[{product-proxy}], which is designed to be a lightweight proxy that handles all real-time requests generated by your client applications during the migration process.
This tool is open-source software.

{product-proxy} is an orchestrator for monitoring application activity and keeping multiple clusters (databases) in sync through dual writes.
{product-proxy} isn't linked to the actual migration process.
It doesn't perform data migrations and it doesn't have awareness of ongoing migrations.
Instead, you use a <<data-migration-tools,data migration tool>> to perform the data migration and validate migrated data.

{product-proxy} reduces risks to upgrades and migrations by decoupling the origin (source) cluster from the target (destination) cluster and maintaining consistency between both clusters.
You decide when you want to switch permanently to the target cluster.

After migrating your data, changes to your application code are usually minimal, depending on your client's compatibility with the origin and target clusters.
Typically, you only need to update the connection string.

[#how-zdm-proxy-handles-reads-and-writes]
=== How {product-proxy} handles reads and writes

{company} created {product-proxy} to orchestrate requests between a client application and both the origin and target clusters.
These clusters can be any xref:cql:ROOT:index.adoc[CQL]-compatible data store, such as {cass-reg}, {dse}, and {astra-db}.

During the migration process, you designate one cluster as the _primary cluster_, which serves as the source of truth for reads.
For the majority of the migration process, this is typically the origin cluster.
Towards the end of the migration process, when you are ready to read exclusively from your target cluster, you set the target cluster as the primary cluster.

The other cluster is referred to as the _secondary cluster_.
While {product-proxy} is active, write requests are sent to both clusters to ensure data consistency, but only the primary cluster serves read requests.

==== Writes (dual-write logic)

{product-proxy} sends every write operation (`INSERT`, `UPDATE`, `DELETE`) synchronously to both clusters at the requested consistency level:

* If the write is acknowledged in both clusters at the requested consistency level, then the operation returns a successful write acknowledgement to the client that issued the request.
* If the write fails in either cluster, then {product-proxy} passes a write failure, originating from the primary cluster, back to the client.
The client can then retry the request, if appropriate, based on the client's retry policy.

This design ensures that new data is always written to both clusters, and that any failure on either cluster is always made visible to the client application.

For information about how {product-proxy} handles Lightweight Transactions (LWTs), see xref:feasibility-checklists.adoc#_lightweight_transactions_and_the_applied_flag[Lightweight Transactions and the applied flag].

==== Reads

By default, {product-proxy} sends all reads to the primary cluster, and then returns the result to the client application.

If you enable _asynchronous dual reads_, {product-proxy} sends asynchronous read requests to the secondary cluster (typically the target cluster) in addition to the synchronous read requests that are sent to the primary cluster.

This feature is designed to test the target cluster's ability to handle a production workload before you permanently switch to the target cluster at the end of the migration process.

With or without asynchronous dual reads, the client application only receives results from synchronous reads on the primary cluster.
The results of asynchronous reads aren't returned to the client because asynchronous reads are for testing purposes only.

For more information, see xref:ROOT:enable-async-dual-reads.adoc[].

=== High availability and multiple {product-proxy} instances

{product-proxy} is designed to be highly available and run a clustered fashion to avoid a single point of failure.

With the exception of local test environments, {company} recommends that all {product-proxy} deployments have multiple {product-proxy} instances.
Deployments typically consist of three or more instances.

[TIP]
====
Throughout the {product-short} documentation, the term _{product-proxy} deployment_ refers to the entire deployment, and _{product-proxy} instance_ refers to an individual proxy process in the deployment.
====

You can scale {product-proxy} instances horizontally and vertically.
To avoid downtime when applying configuration changes, you can xref:ROOT:manage-proxy-instances.adoc#perform-a-rolling-restart-of-the-proxies[perform a rolling restart] of your {product-proxy} instances.

For simplicity, you can use {product-utility} and {product-automation} to set up and run Ansible playbooks that deploy and manage {product-proxy} and its monitoring stack.

== {product-utility} and {product-automation}

You can use {product-automation-repo}[{product-utility} and {product-automation}] to set up and run Ansible playbooks that deploy and manage multiple {product-proxy} instances and the associated monitoring stack (Prometheus metrics and associated Grafana visualizations).

https://www.ansible.com/[Ansible] is a suite of software tools that enable infrastructure as code.
It is open source, and its capabilities include software provisioning, configuration management, and application deployment.

Ansible playbooks streamline and automate the deployment and management of {product-proxy} instances and their monitoring components.
Playbooks are YAML files that define a series of tasks to be executed on one or more remote machines, including installing software, configuring settings, and managing services.
They are repeatable and reusable, and they simplify deployment and configuration management because each playbook focuses on a specific operation, such as rolling restarts.

You run playbooks from a centralized machine known as the Ansible Control Host.
{product-utility}, which is included with {product-automation}, creates the Docker container that acts as the Ansible Control Host.

To use {product-utility} and {product-automation}, you must xref:deployment-infrastructure.adoc[prepare the recommended infrastructure].

For more information about the role of Ansible and Ansible playbooks in the {product-short} process, see xref:setup-ansible-playbooks.adoc[] and xref:deploy-proxy-monitoring.adoc[].

[#data-migration-tools]
== Data migration tools

You use data migration tools to move data between clusters and validate the migrated data.

You can use these tools alone or with {product-proxy}.

=== {sstable-sideloader}

{sstable-sideloader} is a service running in {astra-db} that imports data from snapshots of your existing {cass-short}-based cluster.
This tool is exclusively for migrations that move data to {astra-db}.

For more information, see xref:sideloader:sideloader-overview.adoc[].

=== {cass-migrator}

You can use {cass-migrator} ({cass-migrator-short}) for data migration and validation between {cass-reg}-based databases.
It offers extensive functionality and configuration options to support large and complex migrations as well as post-migration data validation.

You can use {cass-migrator-short} by itself, with {product-proxy}, or for data validation after using another data migration tool.

For more information, see xref:ROOT:cassandra-data-migrator.adoc[].

=== {dsbulk-migrator}

{dsbulk-migrator} extends {dsbulk-loader} with migration-specific commands: `migrate-live`, `generate-script`, and `generate-ddl`.

It is best for smaller migrations or migrations that don't require extensive data validation, aside from post-migration row counts.

You can use {dsbulk-migrator} alone or with {product-proxy}.

For more information, see xref:ROOT:dsbulk-migrator.adoc[].

=== Other data migration processes

Depending on your origin and target databases, there might be other data migration tools available for your migration.
For example, if you want to write your own custom data migration processes, you can use a tool like Apache Spark(TM).

To use a data migration tool with {product-proxy}, it must meet the following requirements:

* Built-in data validation functionality or compatibility with another data validation tool, such as {cass-migrator-short}.

* Avoids or minimizes changes to your data model, including column names and data types.
+
Because {product-proxy} requires that both databases can successfully process the same read/write statements, migrations that perform significant data transformations might not be compatible with {product-proxy}.
The impact of data transformations depends on your specific data model, database platforms, and the scale of your migration.

For data-only migrations that aren't concerned with live application traffic or minimizing downtime, your chosen tool depends on your origin and target databases, the compatibility of the data models, and the scale of your migration.
Describing the full range of these tools is beyond the scope of this document, which focuses on full-scale platform migrations with the {product-short} tools and verified {product-short}-compatible data migration tools.

== In-place migrations

[WARNING]
====
In-place migrations carry a higher risk of data loss or corruption, require progressive manual reconfiguration of the cluster, and are more cumbersome to rollback compared to the {product-short} process.

Whenever possible, {company} recommends using the {product-short} process to orchestrate live migrations between separate clusters, which eliminates the need for progressive configuration changes, and allows you to seamlessly xref:ROOT:rollback.adoc[rollback to your origin cluster] if there is a problem during the migration.
====

For certain migration paths, it is possible to perform in-place database platform replacements on the same cluster where you data already exists.
Supported paths for in-place migrations include xref:6.9@dse:planning:migrate-cassandra-to-dse.adoc[{cass} to {dse-short}] and xref:1.2@hyper-converged-database:migrate:dse-68-to-hcd-12.adoc[{dse-short} to {hcd-short}].

== See also

* xref:ROOT:zdm-proxy-migration-paths.adoc#incompatible-clusters-and-migrations-with-some-downtime[Incompatible clusters and migrations with some downtime]