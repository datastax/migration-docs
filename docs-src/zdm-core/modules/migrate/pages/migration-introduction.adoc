= Introduction to Zero Downtime Migrations

Enterprises today depend on the ability to reliably migrate mission-critical apps and data to cloud environments with zero downtime during the migration.

At DataStax, we've developed a set of thoroughly-tested self-service tools, automation scripts, examples, and documented procedures that walk you through a set of well-defined migration phases.

We call this feature {company} {zdm-product} ({zdm-shortproduct}). 

ZDM provides a simple and reliable way for you to migrate an existing Apache Cassandra&reg; or DataStax Enterprise (DSE) cluster to Astra DB, or to any Cassandra/DSE cluster, without any interruption of service to the apps and data. For example:

* You can move your application to Astra DB with no downtime and with minimal configuration changes
* Your clusters will be kept in sync at all times by a **dual-write logic** configuration
* You can easily rollback at any point, for complete peace of mind

== Migration scenarios

You can migrate:

* From an existing self-managed Cassandra or DSE cluster to cloud-native Astra DB
** Cassandra 3.11.x or 4.0.x to Astra DB
** DSE 5.1.x or 6.8.x to Astra DB
* From an existing Cassandra or DSE cluster to another Cassandra or DSE cluster 
** Cassandra 3.11.x to 4.0.x
** DSE 5.1.x to DSE 6.8.x
* From Astra DB Classic to Astra DB Serverless

== Migration phases

Your migration project can occur through a sequence of phases, with zero downtime, as illustrated in this high-level view.

First, a few important terms:

* The **Origin** cluster is your existing Cassandra-based environment, whether it's open-source Apache Cassandra or DSE.
* The **Target** cluster is the new environment to which you want to migrate apps and data with zero downtime.

image:zdm-migration-phases3.png[Migration phases from start to finish]

. Connecting your clients to the {zdm-proxy}. This activates the dual-write logic: writes will be "bifurcated." Meaning, sent both to your Origin and Target clusters (cloud-native Astra DB, in this case), while reads will be executed on the Origin only.
. Migrating your existing data using the Database Migrator.
. Validating that the migrated data is correct, while continuing to perform dual writes.
. Switching the client app reads to the Target.
. Moving your clients off the {zdm-proxy} and connecting them directly to Target (in this case, Astra DB).

== Migration workflow

Here's a diagram to illustrate the overall migration strategy when moving apps and data from your origin to the target.

image:zdm-workflow1.png[Migration workflow from client to {zdm-proxy} with dual writes to origin and target clusters]

* With no changes required to your client app code itself, {zdm-proxy} does the work to route writes to your origin cluster and to the target Astra DB instance.
* Cassandra Data Migrator and/or DSBulk Migrator can migrate data between clusters of any supported types. See the next section for an introduction to these tools.
* Initially during the migration, {zdm-proxy} always reads from the origin cluster.
* Later during the migration, the read routing is switched to the target so that all reads are executed on it, while writes are still sent to both clusters. In other words, the target becomes the primary source of truth.
* Finally, the client can be moved off the proxy and connected directly to the target, at which point the migration is complete.

== Migration components

The primary component of the migration tool set is **{zdm-proxy}**, which by design is a simple and lightweight proxy that handles all the real-time requests generated by your apps.

The {zdm-proxy} itself doesn't have any capability to migrate data or knowledge that a migration may be ongoing, and it is not coupled to the migration process in any way.

{company} {zdm-product} also provides an Ansible-based {zdm-automation}. It allows you to deploy and manage the {zdm-proxy} instances and its associated monitoring stack. The {zdm-automation} creates a Docker container acting as the Ansible Control Host, from which the Ansible playbooks can be run easily.

Two data migration tools are available to migrate and validate your data. See the xref:migration-introduction.adoc#_cassandra_data_migrator[summary of features] below.

=== Role of {zdm-proxy}

We created {zdm-proxy} to function between the application and the source cluster and Astra DB --  or any CQL-compatible data store -- so that every write operation (Insert, Update, Delete) is passed through to both clusters at the desired Consistency Level:

* If the write is successful in both clusters, it returns a successful acknowledgement to the client
* If the write fails on either cluster, the failure is passed back to the client so that it can retry it as appropriate, based on its own retry policy.

This design allows for write consistency of new data to both clusters. {zdm-proxy} also passes through reads to the configured cluster (initially Origin, and later on Target) and returns the result to the application.

{zdm-proxy} is designed to be highly available. It can be scaled horizontally so typical deployments are made up of a minimum of 3 servers. {zdm-proxy} can be restarted in a rolling fashion, for example, to change configuration for different phases of the migration.

[TIP]
====
{zdm-proxy} has been designed to run in a clustered fashion so that it is never a single point of failure. Unless it is for a demo or local testing environment, a {zdm-proxy} deployment always comprises multiple {zdm-proxy} instances.

We will often use the term **{zdm-proxy}** to indicate the whole deployment, and **{zdm-proxy} instance** to refer to the individual proxy processes in the deployment.
====

=== Key features of {zdm-proxy}

{zdm-proxy}:

* Allows you to lift-and-shift existing application code from the **origin cluster** to the **target cluster** with a simple change of a connection string.

* Reduces risks to upgrades and migrations by decoupling the origin from the target cluster, and allowing there to be an explicit cut-over point once you're satisfied with the target cluster.

* Bifurcates writes to both clusters during the migration process synchronously.

* Returns (for read operations) the response from a designated source of truth. During a migration, the origin cluster typically constitutes the source of truth. Near the end of the migration, you'll shift the source of truth for reads to be the target cluster.

* Can be configured to also read asynchronously from the target cluster. This capability is called **Read Mirroring** (also known as **Asynchronous Dual Reads**) and allows you to observe what read latencies and throughputs the target cluster can achieve without returning those results to the client. The asynchronous read from the target cluster is not sent back to the client. This design implies that failure on asynchronous reading from the target cluster does not cause an error on the client application. Asynchronous reads can be enabled and disabled dynamically with a rolling restart of the proxy instances.

[NOTE]
====
When using Read Mirroring, any additional read load on the target cluster may impact the target cluster's ability to keep up with writes. This behavior is expected and desired. The idea is to mimic the full read and write load on the target cluster so there are no surprises during the last migration phase; that is, after cutting over completely to the target cluster.
====

=== {zdm-automation}

The {zdm-automation} uses **Ansible** to deploy and configure the {zdm-proxy} and monitoring stack via playbooks. The utility expects that you have already provisioned the infrastructure.

https://www.ansible.com/[Ansible] is a suite of software tools that enables infrastructure as code. It is open source and its capabilities include software provisioning, configuration management, and application deployment functionality.

The Ansible automation is organized into playbooks, each implementing a specific operation. The machine from which the playbooks are run is known as the Ansible Control Host. In ZDM, the Ansible Control Host will run as a Docker container.

For details, see:

* xref:migration-setup-ansible-playbooks.adoc[]
* xref:migration-run-ansible-playbooks.adoc[]

=== Data migration tools

As part of the overall migration process, you can use {cstar-data-migrator} to:

* Migrate your data from any Cassandra origin (Cassandra/DSE/Astra DB) to any Cassandra target (Cassandra/DSE/Astra DB)
* Validate migration accuracy and performance using examples that provide a smaller, randomized data set
* Preserve writetimes and Time To Live (TTL) values
* Take advantage of advanced data types (Sets, Lists, Maps, UDTs)
* Filter records from the origin data, using writetime
* Use SSL Support, including custom cipher algorithms

Cassandra Data Migrator is designed to:

* Connect to and compare your target database with the origin
* Report differences in a detailed log file
* Optionally reconcile any missing records and fix any data inconsistencies in the target, if you enable `autocorrect` in a config file

[TIP]
====
An important **prerequisite** is that you already have the matching schema on the target database.
====

You can also take advantage of another data migration tool, {dsbulk-migrator}, to migrate smaller sets of data. 

For more, see xref:migration-validate-data.adoc[Migrate and validate data, window="_blank"].

== Benefits

When moving your apps &amp; data from on-premise Cassandra Query Language (CQL) based data stores (Apache Cassandra or DSE) to a cloud-native database (CNDB) like Astra DB, it's important to acknowledge the fundamental differences ahead. With "on-prem," of course, you have total control of the data center's physical infrastructure, software configurations, and your custom procedures. At the same time, with on-prem clusters you take on the cost of infrastructure resources, maintenance, operations, personnel.

Ranging from large enterprises to small teams, IT managers, operators, and developers are realizing that the Total Cost of Ownership with cloud solutions is much lower than continuing to run on-prem physical data centers.

A CNDB like Astra DB is a different environment. Running on proven cloud providers like AWS, Google Cloud, and Azure, Astra DB greatly reduces complexity and increases convenience by surfacing a subset of configurable settings, providing a well-designed UI known as Astra Portal, and a set of APIs to interact programmatically with your Astra DB organizations and databases.

== What's next?

If you're new here, check out our xref:migration-faqs.adoc[FAQs].

Or jump right in and learn about the recommended xref:migration-infrastructure.adoc[deployment considerations], which include  infrastructure requirements to support your migration.
