= Troubleshooting tips

See the troubleshooting tips in this topic for information that can help you troubleshoot issues with your migration.

== How to retrieve {zdm-proxy} log files

If {zdm-proxy} was deployed using the {zdm-automation}, the utility contains an Ansible playbook that retrieves the logs. For details, see the next xref:migration-troubleshooting-tips.adoc#how-to-view-retrieve-logs[troubleshooting tip].

If you did not use the {zdm-automation}, the steps to retrieve the logs depends on how you deployed the {zdm-proxy}. If
Docker is used, enter the following command to export the logs of a container to a file:

```bash
docker logs my-container > log.txt
```
[TIP]
====
You may need to use `sudo` to run the `docker` command.
====

[TIP]
====
Keep in mind that docker logs are deleted if the container is recreated or restarted.
====

[#how-to-view-retrieve-logs]
== How to retrieve the {zdm-proxy} logs using the {zdm-automation}

When deployed through the {zdm-automation}, each {zdm-proxy} instance runs as a Docker container. You can view its logs by connecting to the proxy machine and running the following command:

```bash
sudo docker container logs zdm-proxy-container
```

You can retrieve logs of all proxy instances using a dedicated playbook: `collect_zdm_proxy_logs.yml`.

If you are using the jumphost as your Ansible control host, no configuration changes are necessary. You can view the playbook's configuration values in `vars/zdm_proxy_log_collection_config.yml`. All default values are fine in most cases:

```bash
ansible-playbook collect_proxy_logs.yml -i zdm_ansible_inventory
```

This playbook creates a single zip file, called `zdm_proxy_logs_<current_timestamp>.zip`, in the desired directory (this defaults to `/home/ubuntu/zdm_proxy_archived_logs` in the Ansible Control Host container). This zip file contains the logs from all proxy instances.

== What to look for in the logs

First of all, make sure that the log level of the {zdm-proxy} is set to the appropriate value:

. If you deployed the proxy through the {zdm-proxy}, the log level is determined by the property `zdm_log_level` in `vars/zdm_proxy_advanced_config.yml`. This value can be changed in a rolling fashion by editing this property and running the playbook `update_zdm_proxy.yml` (see xref:migration-manage-proxy-instances.adoc#change-mutable-config-property[here] for more information)

. If you did not use the {zdm-proxy} to deploy the proxy, change the environment variable `ZDM_LOG_LEVEL` on each proxy instance and restart it.

Here are the most common messages you'll find in the proxy logs.

=== Proxy startup message

Assuming the Log Level is not filtering out `INFO` entries, you can look for the following type of log message in order to verify that the {zdm-proxy} is starting up correctly. Example:

```json
{"log":"time=\"2022-10-01T11:50:48Z\" level=info
msg=\"Proxy started. Waiting for SIGINT/SIGTERM to shutdown.
\"\n","stream":"stderr","time":"2022-10-01T11:50:48.522097083Z"}
```

=== Proxy configuration

The first few lines of the proxy log file contains all the configuration settings and values. They are printed in a long JSON string format. You can copy/paste the string into a JSON formatter/viewer to make it easier to read. Example log message:

```json
{"log":"time=\"2022-10-01T11:50:48Z\" level=info
msg=\"Parsed configuration: {\\\"ProxyIndex\\\":1,\\\"ProxyAddresses\\\":"...",
[remaining of json string removed for simplicity]
","stream":"stderr","time":"2022-10-01T11:50:48.339225051Z"}
```

Seeing the configuration settings is useful while troubleshooting issues. However, remember to check the log level setting to ensure you're viewing the intended types of messages. Setting the log level setting to `DEBUG` might cause a slight performance degradation.

=== Be aware of current log level

When you find a log message that looks like an error, the most important thing is to check the "log level" of that message.

* A log message with `level=debug` or `level=info` is very likely not an error, but something expected and normal.

* Log messages with `level=error` must be examined as they usually indicate an issue with the proxy, the client application, or the clusters.

* Log messages with `level=warn` are usually related to events that are not fatal to the overall running workload, but may cause issues with individual requests or connections.

* In general, log messages with `level=error` or `level=warn` should be brought to the attention of DataStax, if the meaning is not clear.  In the {zdm-proxy} GitHub repo, submit a https://github.com/datastax/zdm-proxy/issues[GitHub Issue^] to ask questions about log messages of type `error` or `warn` that are unclear.

=== Protocol log messages

Here's an example of a log message that looks like an error, but it's actually an expected and normal message:

```json
{"log":"time=\"2022-10-01T12:02:12Z\" level=debug msg=\"[TARGET-CONNECTOR]
Protocol v5 detected while decoding a frame. Returning a protocol message
to the client to force a downgrade: PROTOCOL (code=Code Protocol [0x0000000A],
msg=Invalid or unsupported protocol version (5)).\"\n","stream":"stderr","time":"2022-10-01T12:02:12.379287735Z"}
```

There are cases where protocol errors are fatal so they will kill an active connection that was being used to serve requests. However, if you find a log message similar to the example above with log level `debug`, then it's likely not an issue. Instead, it's more likely an expected part of the handshake process during the connection initialization; that is, the normal protocol version negotiation.

== How to identify the {zdm-proxy} version

In the {zdm-proxy} logs, the first message contains the version string (just before the message that shows the configuration):


```
time="2022-10-11T13:37:28+01:00" level=info msg="Starting ZDM proxy version 2.0.0"
time="2022-10-11T13:37:28+01:00" level=info msg="Parsed configuration: {removed for simplicity}"
```

You can also provide a `-version` command line parameter to the {zdm-proxy} and it will only print the version.

```bash
> docker run --rm datastax/zdm-proxy:2.0.0 -version
ZDM proxy version 2.0.0
```

[TIP]
====
Do not use `--rm` when actually launching the {zdm-proxy} otherwise you will not be able to access the logs when it stops (or crashes).
====

== How to leverage the metrics provided by {zdm-proxy}

The {zdm-proxy} exposes an HTTP endpoint that returns metrics in the Prometheus format. At the moment this is the only way to obtain metrics from {zdm-proxy}, we plan to introduce other ways to expose metrics in the future. 

The {zdm-automation} can deploy Prometheus and Grafana, configuring them automatically. The Grafana dashboards are ready to go with metrics that are being scraped from the {zdm-proxy} instances. 

If you already have a Grafana deployment then you can import the dashboards from the two ZDM dashboard files https://github.com/datastax/zdm-proxy-automation/tree/main/grafana-dashboards[on this location^].

=== Grafana dashboard for {zdm-proxy} metrics

There are three groups of metrics in this dashboard:

* Proxy level metrics
* Node level metrics
* Asynchronous read requests metrics

image:zdm-grafana-proxy-dashboard1.png[Grafana dashboard shows three categories of ZDM metrics for the proxy.]

==== Proxy-level metrics

* Latency
** Read Latency - total latency measured by the {zdm-proxy} (including post processing like response aggregation) for read requests. This metric has two labels (reads_origin and reads_target), the label that has data will depend on which cluster is receiving the reads (controlled by the `ZDM_PRIMARY_CLUSTER` configuration setting of the {zdm-proxy}).
** Write Latency- total latency measured by the {zdm-proxy} (including post processing like response aggregation) for write requests.

* Throughput (same structure as the previous latency metrics)
** Read Throughput
** Write Throughput

* In-flight requests

* Number of client connections

* Prepared Statement cache
** Cache Misses - meaning, a prepared statement was sent to the {zdm-proxy}, but it wasn't on its cache, so the proxy returned an `UNPREPARED` response to make the driver send the `PREPARE` request again
** Number of cached prepared statements

* Request Failure Rates - Number of request failures per interval. You can set the interval via the `Error Rate interval` dashboard variable at the top.
** Read Failure Rate - one `cluster` label with two settings: `origin` and `target`. The label that contains data depends on the `ZDM_PRIMARY_CLUSTER` setting (same as the latency and throughput metrics)
** Write Failure Rate - one `failed_on` label with three settings: `origin`, `target` and `both`
*** `failed_on=origin` - the write request failed on the Origin cluster ONLY
*** `failed_on=target` - the write request failed on the Target cluster ONLY
*** `failed_on=both` - the write request failed on BOTH clusters

* Request Failure Counters - Number of total request failures (resets when the {zdm-proxy} instance is restarted)
** Read Failure Counters - same labels as read failure rate
** Write Failure Counters - same labels as write failure rate

To see error metrics by error type, see the node-level error metrics on the next section.

==== Node-level metrics

* Latency - metrics on this bucket are not split by request type like the proxy level latency metrics so writes and reads are mixed together
** Origin - latency measured by the {zdm-proxy} up to the point it received a response from the Origin connection
** Target - latency measured by the {zdm-proxy} up to the point it received a response from the Target connection

* Throughput - same as node level latency metrics, reads and writes are mixed together

* Number of connections per ORIGIN node and per TARGET node

* Number of errors per error type per ORIGIN node and per TARGET node. Possible values for the `error` type label:
** `error=client_timeout`
** `error=read_failure`
** `error=read_timeout`
** `error=write_failure`
** `error=write_timeout`
** `error=overloaded`
** `error=unavailable`
** `error=unprepared`

==== Asynchronous read requests metrics

These metrics are specific to asynchronous reads so they are only populated if asynchronous dual reads are enabled (`ZDM_READ_MODE=DUAL_ASYNC_ON_SECONDARY`).

* Latency
* Throughput
* Number of dedicated connections per node for async reads - whether it's ORIGIN or TARGET connections depends on the {zdm-proxy} configuration. That is, if the primary cluster is `ORIGIN` then the asynchronous reads are sent to TARGET.
* Number of errors per error type per node

==== Insights via the {zdm-proxy} metrics

Some examples of problems manifesting on these metrics:

* Number of client connections close to 1000 per {zdm-proxy} instance -  By default, {zdm-proxy} starts rejecting client connections after 1000.
* Always increasing PS cache metrics - both the **entries** and **misses** metrics
* Error metrics depending on the error type - these need to be evaluated on a per-case basis

=== Go runtime metrics dashboard and system dashboard

This dashboard in Grafana is not as important as the {zdm-proxy} dashboard. However, it may be useful to troubleshoot performance issues. Here you can see memory usage, Garbage Collection (GC) duration, open fds (file descriptors - useful to detect leaked connections), and the number of goroutines:

image:zdm-golang-dashboard.png[Golang metrics dashboard example is shown.]

Some examples of problem areas on these Go runtime metrics:

* An always increasing “open fds” metric
* GC latencies in (or close to) the triple digits of milliseconds frequently
* Always increasing memory usage
* Always increasing number of goroutines

The ZDM monitoring stack also includes a system-level dashboard collected through the Prometheus Node Exporter. This dashboard contains hardware and OS-level metrics for the host on which the proxy runs. This can be useful to check the available resources and identify low-level bottlenecks or issues.

== Reporting an issue

If you encounter a problem during your migration, please contact us. In the {zdm-proxy} GitHub repo, submit a https://github.com/datastax/zdm-proxy/issues[GitHub Issue^]. Only to the extent that the issue's description does not contain **your proprietary or private** information, please include the following:

* {zdm-proxy} version
* {zdm-proxy} logs - ideally at `debug` level if you can reproduce the issue easily and can tolerate a restart of the proxy instances to apply the configuration change
* Version of database software on the Origin and Target clusters (relevant for DSE and Apache Cassandra deployments only)
* If Astra DB is being used, please let us know in the issue description.
* Screenshots of the {zdm-proxy} metrics dashboards from Grafana or whatever visualization tool you use. If you can provide a way for us to access those metrics directly that would be even better.
* Application/Driver logs
* Driver and version that the application is using

=== Reporting a performance issue

If the issue is related to performance, troubleshooting can be more complicated and dynamic. Because of this we request additional information to be provided which usually comes down to the answers of a few questions (in addition to the information from the prior section):

* Which statement types are being used: simple, prepared, batch?
* If batch statements are being used, which driver API is being used to create these batches? Are you passing a `BEGIN BATCH` cql query string to a simple/prepared statement? Or are you using the actual batch statement objects that drivers allow you to create?
* How many parameters does each statement have? 
* Is cql function replacement enabled? You can see if this feature is enabled by looking at the value of the Ansible advanced configuration variable `replace_cql_functions` if using the automation, or the environment variable `ZDM_REPLACE_CQL_FUNCTIONS` otherwise. CQL Function replacement is disabled by default.
* If permissible within your security rules, please provide us access to the {zdm-proxy} metrics dashboard. Screenshots are fine but for performance issues it is more helpful to have access to the actual dashboard so the team can use all the data from these metrics in the troubleshooting process.

== What's next?

Refer to the xref:migration-troubleshooting-scenarios.adoc[].
